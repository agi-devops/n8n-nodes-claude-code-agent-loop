import { exec } from 'child_process';
import { promisify } from 'util';
import type { RepoConfig } from './worktree.js';

const execAsync = promisify(exec);

export interface PRResult {
  repoName: string;
  url: string;
  number: number;
}

export interface MultiPRResult {
  taskId: string;
  prs: PRResult[];
  linkedDescription: string;  // PR body with cross-links
}

/**
 * Creates a single PR via the Gitea CLI.
 */
async function createSinglePR(
  config: RepoConfig,
  branch: string,
  baseBranch: string,
  title: string,
  body: string
): Promise<PRResult> {
  const repoPath = `${config.giteaOwner}/${config.giteaRepo}`;

  // Escape quotes in title and body for shell
  const safeTitle = title.replace(/"/g, '\\"').replace(/`/g, '\\`');
  const safeBody = body.replace(/"/g, '\\"').replace(/`/g, '\\`');

  try {
    const { stdout } = await execAsync(
      `/home/node/bin/gitea pr:create ${repoPath} ${branch} ${baseBranch} "${safeTitle}" --body="${safeBody}"`,
      { timeout: 30000 }
    );

    // Parse PR number from output like "PR #123 created"
    const prMatch = stdout.match(/PR #(\d+)/);
    const prNumber = prMatch ? parseInt(prMatch[1], 10) : 0;

    return {
      repoName: config.repoName,
      url: `https://gitea.devops.methode5.at/${repoPath}/pulls/${prNumber}`,
      number: prNumber
    };
  } catch (error) {
    console.error(`Failed to create PR for ${repoPath}:`, error);
    throw error;
  }
}

/**
 * Updates a PR body via Gitea API.
 */
async function updatePRBody(
  config: RepoConfig,
  prNumber: number,
  body: string
): Promise<void> {
  const repoPath = `${config.giteaOwner}/${config.giteaRepo}`;

  // Escape the body for JSON
  const jsonBody = JSON.stringify({ body });

  try {
    await execAsync(
      `/home/node/bin/gitea raw:patch repos/${repoPath}/pulls/${prNumber} '${jsonBody}'`,
      { timeout: 30000 }
    );
  } catch (error) {
    console.warn(`Failed to update PR body for ${repoPath}#${prNumber}:`, error);
    // Don't throw - PR was created, just couldn't update body
  }
}

/**
 * Creates PRs for all repos that have changes.
 * PRs are cross-linked so reviewers can see related changes.
 */
export async function createMultiRepoPRs(options: {
  taskId: string;
  repos: Map<string, { branch: string; config: RepoConfig }>;
  baseBranch: string;
  title: string;
  body: string;
}): Promise<MultiPRResult> {
  const prs: PRResult[] = [];
  const repoList = Array.from(options.repos.entries());

  if (repoList.length === 0) {
    return {
      taskId: options.taskId,
      prs: [],
      linkedDescription: options.body
    };
  }

  // First pass: create all PRs with placeholder body
  for (const [, { branch, config }] of repoList) {
    try {
      const pr = await createSinglePR(
        config,
        branch,
        options.baseBranch,
        options.title,
        'Creating PR... (will update with links)'
      );
      prs.push(pr);
    } catch (error) {
      console.error(`Failed to create PR for ${config.repoName}:`, error);
      // Continue with other repos
    }
  }

  // Build cross-linked description
  let linkedDescription = options.body + '\n\n---\n\n## Related PRs\n\n';
  linkedDescription += `Task ID: \`${options.taskId}\`\n\n`;
  for (const pr of prs) {
    linkedDescription += `- [${pr.repoName}: PR #${pr.number}](${pr.url})\n`;
  }
  linkedDescription += '\n\n---\n*Generated by Claude Agent*';

  // Second pass: update PRs with cross-links
  for (const pr of prs) {
    const repoData = options.repos.get(pr.repoName);
    if (repoData) {
      await updatePRBody(repoData.config, pr.number, linkedDescription);
    }
  }

  return {
    taskId: options.taskId,
    prs,
    linkedDescription
  };
}

/**
 * Creates a single PR for a single repo (simpler case).
 */
export async function createPR(options: {
  config: RepoConfig;
  branch: string;
  baseBranch: string;
  title: string;
  body: string;
}): Promise<PRResult> {
  return createSinglePR(
    options.config,
    options.branch,
    options.baseBranch,
    options.title,
    options.body
  );
}
